---
title: "SegmentNotFoundException和IllegalArgumentException"
description: 說明
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/offline-compaction-fails-with-SegmentNotFoundException-and-IllegalArgumentException.html"
bug: false
article-created-by: Emily Geary
article-created-date: "4/12/2021 6:09:12 PM"
article-published-by: Emily Geary
article-published-date: "4/12/2021 6:09:50 PM"
version-number: 7
article-number: KA-16457
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=7ed24a2d-ba9b-eb11-b1ac-000d3a3680d8"
exl-id: 54f6bac4-f81b-4685-89e6-eaedf60f3552
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '956'
ht-degree: 0%

---

# SegmentNotFoundException和IllegalArgumentException

## 說明


當存放庫存在完整性問題時，執行離線壓縮可能會因SegmentNotFoundException而失敗。

您在AEM記錄檔中觀察到SegmentNotFoundException，而AEM未如預期運作

或

當存放庫存在完整性問題時，執行離線壓縮可能會因SegmentNotFoundException而失敗。 您可以在記錄中找到類似下列的堆疊追蹤：

`13:51:21.523 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 4d139bc4-150c-4f0a-b82a-40a4e519fe8a. Creation ` `date` `delta is 4 ms.`

`org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855) oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)  oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) oak-run-1.0.22.jar:1.0.22`

`...`

`Exception ` `in` `thread ` `"main"` `org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101)`

`...`

或

如果存放庫存在完整性問題，執行離線壓縮可能會因IllegalArgument Exception而失敗。 您可以在記錄中找到類似下列的堆疊追蹤：


| `java.lang.IllegalArgumentException`<br><br>`at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.(ListRecord.java:41)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntry(ListRecord.java:64)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:81)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentStream.` `read` `(SegmentStream.java:153)`<br><br>`at org.apache.jackrabbit.oak.commons.IOUtils.readFully(IOUtils.java:53)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.getBlobKey(Compactor.java:412)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:362)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:321)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.access$500(Compactor.java:54)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.propertyAdded(Compactor.java:227)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.propertyAdded(CancelableDiff.java:47)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:156)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)` |
| --- |


<b>原因</b>

當壓縮嘗試讀取節點時區段不存在時，會傳回SegmentNotFoundException。 原因可能不同：

1. 已通過手動干預（如rm -rf /）刪除該段。
2. 區段已由修訂垃圾收集移除。
3. 由於程式碼中出現錯誤，找不到區段。


如果是由修訂垃圾收集(Point 2)導致的問題，請確保禁用聯機壓縮，以避免更多節點損壞。


## 解析度


我們可以遵循多個過程來解決此情況，並成功完成離線壓縮。

*重要：* 執行下列步驟之前，請先對存放庫執行完整備份。



<b>A.回復至區段存放區的上次確認正確修訂版本。</b>

oak-run的檢查執行模式可用來判斷區段存放區最後已知良好的修訂版本。 這可用來手動將損壞的區段存放區還原為其最新的良好修訂。

*注意：<b>* </b>此過程會將系統中的資料回滾到以前的時間點。  如果您想要避免遺失系統中的變更，可以改為嘗試下方的選項B。

要執行檢查和還原，請執行以下操作：

1. 從這裡下載oak-run jar檔案 [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/)
2. 停止AEM。
3. 運行以下命令：

   `java -jar oak-run-*.jar check --bin=-1 crx-quickstart/repository/segmentstore/`



   此命令會回溯搜尋修訂版本，直到找到一致的修訂版本為止：

   `14:00:30.783 main INFO  o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880`



   （如果ConsistencyChecker失敗，請轉至下一節）


4. 通過編輯將儲存庫還原為此修訂版本。

   `/crx-quickstart/repository/segmentstore/journal.log.`



   刪除包含最新良好修訂的行之後的所有行。 如果想了解要還原儲存庫的日期和時間，請在segmentstore資料夾中運行此命令（將afdb922d-ba53-4a1b-aa1b-1cb044b535cf替換為journal.log中的最新良好修訂）:

   `find . -type f -name "data*.tar" -exec sh -c "tar -tvf {} |grep afdb922d-ba53-4a1b-aa1b-1cb044b535cf" \; -print`



   輸出會顯示該修訂的約略日期和時間。


5. 全部移除 `./crx-quickstart/repository/segmentstore/*.bak files.`
6. 如果使用AEM6.0，請下載與AEM中所安裝內容相符的oak-run版本，以執行其餘步驟。  從這裡下載 [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/).
7. 執行查核點清除以移除孤立的查核點：

   `java -jar oak-run-*.jar checkpoints ./crx-quickstart/repository/segmentstore rm-unreferenced.`


8. 最後，壓縮儲存庫：

   `java -jar oak-run-*.jar compact ./crx-quickstart/repository/segmentstore/`




<b>B.手動刪除損壞的節點。</b>

在AEM中，若未設定FileDatastore且二進位檔中發生損毀，您可以執行下列操作。

*注意：*以下程式適用於高級用戶。  刪除損壞的節點時，您需要確保它們不是系統節點（如/home、/jcr:system等）。  或者，如果它們是系統節點，則需要確保可以恢復它們。  如果您不確定，請洽詢AEM客戶服務團隊，以取得此處說明的步驟協助。

1. 停止AEM。
2. 使用Oak執行主控台並載入childCount groovy指令碼，以識別區段存放區中損毀的節點：

   載入oak-run主控台殼層：

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   在shell中運行以下兩個命令以載入指令碼並運行它：

   `:load`

   `https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy`

   `countNodes(session.workingNode)`



   這會導致以下輸出指示損壞節點的路徑：

   `21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms.`

   `warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content`



   在某些情況下，問題連結到二進位屬性，而childCount groovy指令碼找不到任何損壞的節點。  在這些情況下，您可以使用以下命令來代替遍歷過程中遇到的每個二進位元組的前1024個位元組（請注意，此命令的速度會較慢，並且僅當上述命令未返回預期結果時才應使用）:

   `countNodes(session.workingNode,true)`


3. 使用rmNodes.groovy刪除最後一個命令輸出中列出的所有已標識的損壞節點

   載入oak-run主控台殼層：

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   載入groovy指令碼：

   `:load`

   `https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy`



   運行rmNode命令以刪除損壞的節點，用需要刪除的損壞節點的路徑替換/path/to/corrupt/node。

   `rmNode(session, "/path/to/corrupt/node")`



   其中損壞的節點路徑是在步驟2中獲得的路徑，例如： `"/content/dam/test.txt/jcr:content/renditions/original/jcr:content/"`
注意：使用oak-run.jar 1.6.13版和更新時，如果您遇到錯誤，請設定 — 讀寫JVM參數，例如：






   ```
   / rmNode(session,"/path/to/corrupt/node")    Removing node /path/to/corrupt/node    ERROR java.lang.UnsupportedOperationException:    Cannot write to read-only store    at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171)    at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318)    at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333)    at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source)    at groovysh_evaluate.rmNode (groovysh_evaluate:11)
   ```

4. 對於在步驟2中找到的所有節點，重複步驟3。

   對於損壞的路徑，上述rmNode命令應返回true，這表示它已將其刪除。 通過在這些路徑上重新運行rmNode命令，確保刪除這些發現的三個損壞路徑。 下次執行時應會傳回false。

   如果您仍然看到存放庫中有相同的路徑，請使用修補版本的oak-run jar，即oak-run-1.2.18-NPR-17596

   Oak run Jar的修補版本是什麼？

   此版本的jar會在壓縮時略過無法讀取的二進位檔，取代為0位元組二進位檔，並記錄例外狀況和syser的路徑。 如此一來，已壓縮的存放庫應會傳遞oak-run檢查、節點計數指令碼，而您也應能使用未修補的oak-run再次將其壓縮。


5. 使用下方列出查核點，以執行查核點清除。 如果有多個查核點，請加以清除：

   `nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &`
6. 執行離線壓縮。  如果您不知道如何執行離線壓縮，請參閱 [此處](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).
7. 啟動伺服器等待索引完成。
