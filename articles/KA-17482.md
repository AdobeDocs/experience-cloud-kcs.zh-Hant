---
title: 「分析記憶體問題」
description: 說明
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: 「KCS」
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 100%

---

# 分析記憶體問題

## 說明

<br>症狀<br><br>
此[!DNL Java]應用程式執行速度會變慢且最後會用盡記憶體，或者您會在紀錄或主控台輸出 `OutOfMemoryError: Java heap space` 或 `OutOfMemoryError: gc overhead limit exceeded` 中看到錯誤。
<br><br>原因<br><br>
這類問題可能有很多原因。

在我們的情況下，一個可能的原因是 [!DNL Java] 應用程式 CRX / CQ 是從命令列啟動，包含 [!DNL Java] 的預設堆積記憶體設定。這表示並未指定 jvm 參數 `-Xmx`。CRX 或 CQ 至少需要分配 256 MB 的堆積才能執行。如果這是問題所在，則從命令列開始，確保堆積記憶體已設定。範例：


```
java -Xmx512m -jar *.jar
```


如果不是這種情況，那麼您的應用程式可能會保留過多對象而沒有為垃圾收藏集釋出它們。這稱為記憶體外洩，請參閱[此處](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)以了解詳細資訊。請參閱下面有關如何分析 Java 應用程式中的記憶體問題的區段。


## 解析度

建立堆積傾印<br><br>自動產生堆積傾印<br><br>
若要在用盡記憶體時自動建立堆積傾印，您可新增 jvm 參數 `-XX:+HeapDumpOnOutOfMemoryError` 以在應用程式擲回 `OutOfMemoryError` 時自動產生堆積傾印。例如，


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


這會在流程的工作目錄中產生堆積傾印檔案 (`java_...hprof`)，只要 `java` 流程的記憶體不足即會進行。產生堆積傾印後，該流程可以繼續執行。通常，一個堆積傾印檔案就足以分析問題。

<b>注意：</b>如果您正在使用 `crx-quickstart/server/start` 指令碼來啟動您的 CRX 執行個體，則您可以將 `-XX:+HeapDumpOnOutOfMemoryError` 新增到 `CQ_JVM_OPTS` 變數 (也確保對變數取消註解)。例如：


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


新增此參數並重新啟動 CRX 執行個體後，驗證是否設定了新的 jvm 選項。從命令列執行 `ps -ef | grep java`。然後檢查您是否看到 `-XX:+HeapDumpOnOutOfMemoryError` 作為 CRX `java` 參數的流程。

如果由於磁碟空間限制需要指定不同的目錄來產生堆積傾印，則可以新增 `-XX:HeapDumpPath=/path/to/generate/heapdump` 參數，以告知 jvm 將檔案放在哪裡。

請參閱[此處](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)以取得偵錯相關 jvm 參數的參考資料。
<br><br>手動產生堆積傾印<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

若要手動產生推積傾印，請執行此命令 (jmap 和 jps 可以在您的 jdk 主目錄的 `bin` 文件夾中找到)：

1. 查找您正在為其產生堆積傾印的 `java` 流程的 pid。
   - 這可在 [!DNL Unix] 或 [!DNL Linux] 中完成 `ps -ef | grep java` 或 `jps -l`
   - 在 [!DNL Windows] 中，這可以透過開啟任務管理員來完成，按下 `Ctrl+Shift+Esc`，然後前往<b>檢視</b> = <b>選取欄</b> = <b>PID (流程識別碼)</b> 或者 `jps -l`
2. 執行下面的 jmap 命令，將 `/path/to/generate/heapdumpfile.hprof` 以您要產生堆積傾印檔案的位置取代，然後將 `1234` 以您在上一步中查找的 pid 取代。

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

您首先必須變更有關傾印代理程式的預設 JVM 設定，以在使用者訊號上產生正確的傾印。有幾種傾印，但您通常需要完整的<b>系統傾印</b>以執行徹底的記憶體分析。 新增以下引數：

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

當 JVM 收到來自作業系統的 SIGQUIT ([!DNL Linux]、AIX®、z/OS® 和 i5/OS™) 或 SIGBREAK ([!DNL Windows]) 訊號。

如需詳細資訊，請參閱[此處](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html)供應商的文件。

<b>警告：</b>推積傾印檔案很大，最大並可能達到和您最大堆積 `-Xmx` jvm 參數設定相同的磁碟大小。確保您有足夠的磁碟空間分配給產生傾印檔案的目錄。
<br><br>分析堆積傾印<br><br>
分析堆積傾印的適合工具是 [!DNL Eclipse]MAT ([!DNL Eclipse Memory Analyzer])：[http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

此工具無法分析 <b>IBM JVM</b> 已產生的傾印。對於上述情況，有幾種可能性。 [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) 將適用於 PHD 或傳統格式中的堆積傾印。

若要進行完整的系統傾印分析，請使用 [IBM 支援助理工作台](http://www-01.ibm.com/software/support/isa/) 以及安裝在頂端 [適用於 Java 的 IBM 監視和診斷工具 - 記憶體分析器版本 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/)。
<br><br>堆積長條圖<br><br>
此堆積長條圖是按 [!DNL Java] 類別使用的即時物件與記憶體數的簡易測量。不幸的是，視 [!DNL Java] 安裝而定，所需的工具可能無法取得或可能並不一定有效。若要建立堆積長條圖，您首先需要 [!DNL Java] 流程的流程 id。若要取得，請執行 `ps` 或 (如果有) 執行：


```
jps -l
```


此 [!DNL Java] 工具取得所有正在執行 [!DNL Java] 流程的流程 id。範例：


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


現在執行以下命令：


```
jmap -histo 3313
```


該清單會按所需的總記憶體排序 (淺：不包括參照的物件)。輸出的前 20 行是最有趣的。輸出範例：


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>其他資訊</b>

為了協助分析問題，我們還需要了解以下資訊：

- CRX 或 CQ 版本，包括所有已安裝的 Hot Fix 版本編號清單。
- 作業系統、JVM 供應商和版本。


<b>參考資料</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
