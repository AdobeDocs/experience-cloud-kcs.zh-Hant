---
title: "AEM線程轉儲分析"
description: 說明
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html"
bug: false
article-created-by: Emily Geary
article-created-date: "3/17/2021 9:11:03 PM"
article-published-by: Emily Geary
article-published-date: "3/17/2021 9:13:37 PM"
version-number: 2
article-number: KA-16458
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e70a8345-6587-eb11-a812-000d3a593216"
exl-id: 74bb70e4-a09b-48fc-8378-96a1736e5ebf
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1002'
ht-degree: 0%

---

# AEM執行緒傾印分析

## 說明


使用分析AEM Java線程轉儲 [IBM線程分析器](http://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) 工具。


## 解析度


1. 下載並安裝 [IBM線程分析器](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=2245aa39-fa5c-4475-b891-14c205f7333c) (簡稱IBMTDA)
2. 擷取 [線程轉儲](https://helpx.adobe.com/experience-manager/kb/TakeThreadDump.html) 從AEM例項發生效能問題時傳送。
3. 在IBM TDA中開啟執行緒傾印。
4. 要查看線程轉儲的詳細資訊，請選擇清單中的檔案，然後按一下「線程詳細資訊」按鈕\*。

![tda-threaddetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1587732783/tda-threaddetail.png "tda-threaddetail")
5.依「堆疊深度」排序，頂端堆疊最長。

![tda-image1](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image/tda-image1.png)
6.查看堆棧深度為10行或更長的線程。  這通常是最感興趣的問題。  在感興趣的線程上記筆記。
7.按線程「狀態」排序8.向下滾動到「可運行」線程。 可運行線程是執行線程轉儲時主動佔用CPU時間的線程。

*注意：查看「可運行」線程時，可以忽略 [可忽略的線程](https://helpx.adobe.com/experience-manager/kb/thread-dump-analysis.html#ignorethreads) 區段。*
9.查找屬於應用程式的可運行線程，例如，後台作業線程或請求線程(請求線程的名稱類似於 *127.0.0.1 1347028187737GET/content/sites/global/en/sitemap.static-delivery.httpd.html HTTP/1.1*)。 找到它們後，按一下它們。
10.對於每個請求線程，可通過查看線程名稱中的時間戳來查找用戶的瀏覽器向伺服器發出請求的時間。  例如，在上述執行緒名稱中，時間戳記（以毫秒為單位的unix紀元格式）為1347028187737。  我們可以使用 [www.epochconverter.com](http://www.epochconverter.com/).  每個執行緒傾印都會顯示擷取的日期和時間。  您可以利用請求時間和線程轉儲時間之間的時間差異，查看某個請求已處於活動狀態的時間。
11.在檢閱請求線程後，捲動其他「可運行」線程。  找到「可運行」的目標線程後，查看中間面板，即「等待線程」。  列出的線程正在等待所選線程釋放監視器。  如果您沒有看到任何等待線程，則選定線程仍可能是 [鎖定](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) (請參閱實作類別 [鎖定](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html) 詳細資訊)。 例如，使用 [ReentrantReadWriteLock](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html) 當鎖在內部實施多個監視器時，您無法判斷哪個線程是鎖保持器。  因此，您可能需要查看原始碼，以便與一個線程匹配，該線程可能是鎖的保持器。
12.如果線程有鎖定或監視其他許多線程正在等待，則請通過線程轉儲的其餘部分，查看是否可以找到其他線程存在相同問題。  查看其他轉儲中是否仍存在同一線程(在IBM TDA中，您可以選擇多個線程轉儲，然後按一下「比較線程」按鈕\*以查看多個線程轉儲中的線程狀態。

![tda-comparethreads](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1159496390/tda-comparethreads.png)
13.請參閱下面螢幕截圖中的Collector Service :

![tda-Image2](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1730877898/tda-Image2.png)
14.在此視圖中，您可以查看多個線程轉儲中的線程，以查看它是否是長時間運行的線程。  基本上，如果線程在多個轉儲中處於可運行狀態，且堆棧長，則通常意味著該線程運行時間較長。
15.如果您在查看可運行線程時沒有發現太多，請返回到線程清單，選擇一個線程轉儲，然後按一下頂部面板上的「監視詳細資訊」按鈕\*。 IBM TDA將開啟一個窗口，其中顯示監視器所屬線程及其等待線程的樹視圖。 注意：它可能顯示一些線程池線程，如Servlet引擎線程池監視器，可忽略空閒線程。  通常，您可以判斷線程是空閒線程池線程，因為大多數時候它們只有10條或更少的堆棧行。

![tda-monitordetail](https://helpx.adobe.com/content/dam/help/en/experience-manager/kb/thread-dump-analysis/_jcr_content/main-pars/image_1106466084/tda-monitordetail.png)




<b>線程級CPU利用率（僅限Linux平台）:</b>

1. 如果除了線程轉儲外還捕獲了「top -H -b -n1 -p javapid」輸出，則可以交叉引用線程級CPU利用率。  開啟頂端輸出，獲取正在使用CPU的線程的進程ID。  將進程ID轉換為十六進位，然後在相應的線程轉儲檔案中搜索該十六進位值。  id應符合其中一個執行緒的「nid」。
2. 如果使用最多CPU的匹配線程是「VM線程」或任何「GC」線程，則您可能遇到記憶體問題。  對更多線程轉儲和頂部輸出重複相同的練習，如果這些線程的模式佔用CPU時間，則會出現記憶體問題。
3. 如果已確認記憶體問題，則下次出現問題時捕獲堆轉儲。  請參閱 [這篇文章](https://helpx.adobe.com/experience-manager/kb/AnalyzeMemoryProblems.html) 有關捕獲和分析堆轉儲的詳細資訊。


![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)![](https://helpx.adobe.com/libs/cq/ui/resources/0.gif)

可忽略的線程：

- 虛擬機線程：這是VM系統線程。
- 以GC任務線程啟動的線程：這些是垃圾收集線程。
- 在java.net.PlainSocketImpl.socketAccept（Native方法）的代碼中，名稱類似 — 1347028691218的線程：這些線程來自servlet引擎的線程池，等待新連接。
