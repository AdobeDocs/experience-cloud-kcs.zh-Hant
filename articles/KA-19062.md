---
title: 在AEM 6.x中回報「問題」時，如何除錯SegmentNotFoundException
description: 說明
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# 在AEM 6.x中回報「問題」時，如何除錯SegmentNotFoundException

## 說明


<b>在AEM 6.x中回報「問題」時，如何除錯SegmentNotFoundException</b>

A <b>SegmentNotFoundException</b> 在錯誤記錄中，表示雖然有人顯然仍嘗試存取該區段，但該區段已不存在。 原因大致有三種：區段已透過手動干預（例如rm -rf /）移除，區段已透過修訂垃圾收集移除，或因程式碼中出現錯誤而找不到區段。

記錄中可能會出現例外狀況，例如：

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException:區段d2c720c4-c146-4ab1-ac37-542aad93c33f在org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602)at org.apache.jackrabbit.oak.segment.file.FileStore$8.call(JavaStore.542)at.ache.og.seSegment.eg.Ok.ab.gSegmentCach.segmentCache.java:95)，位於org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:542)，位於org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125)，位於org.apache.oak.oak.segment.getSegment(Record.jab.map.recok.record.mp.mp.record.met4)at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433)，位於org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391)，位於org.apache.jackrabbit.ok.segmentNodeState.compareBateSate(SegmentNodeState.java:608),ate.org.diff.javi.javachedi.corb.corb.e.corb.comit.ch.ch.chedECorbitEECordEEEdEdEditorCor.chedColdCompedEditor(Comper.Compe.java:148)，位於org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java:442)，位於org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490)，位於org.apache.jackrabbit.segment.Maparecore.java(Java:4333),ate.org.ore.se.se.seg.segmentSeSeSeSeg.seSempateSeSeSeg.segmpategmentSeSeSegmentSegmpateSegmentSegmentSegm(SegmentNodeState.java:608)，位於org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52)，位於org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.ja:695)，位於org.apache.plugins.oak.index.AsyncUpdate.runEx（允許的IndeInde.org:ac.ac.ac.apa.ac.update）jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402)at org.apache.sling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobJobExecutor.java:118)at org.quartz.core.JobRunShell.run(Java:20)at.java.util.cutor.Thr.tecor.tor.l.r.executor.r.r.r.r.r.r.r.r.rR.r.rJavaR.uecusor.RRR(JavaJavaJaJaJor:11:JavaJavaDecutor:Java42)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)at java.lang.Thread.run(Thread.java:745)

...


## 解析度


我們可以採取2種方法來修正問題，並移除下文A和B節所述存放庫中的不一致之處。

<b>A.回復至區段存放區的上次確認正確修訂版本。</b>

首先，我們需要使用oak執行工具，此工具為可執行的jar1，包含您進行簡單Oak安裝及執行與oak相關作業所需的一切。

oak-run的檢查執行模式可用來判斷區段存放區最後已知良好的修訂版本。  這可用來手動將損壞的區段存放區還原為其最新的良好修訂。

*注意：此程式會將系統中的資料回復至先前的時間點。  如果您想要避免遺失系統中的變更，可以改為嘗試下方的選項B。*

要執行檢查和還原，請執行以下操作：

1. 從下載符合您Oak核心版本的oak-run版本 [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. 要將損壞的段儲存還原為其最新的良好狀態更改，請將其還原到CQ的工作目錄（包含crx-quickstartfolder的目錄）中，並備份中的所有檔案。/crx-quickstart/repository/segmentstore/。
3. 執行一致性檢查，java -Xmx6000m -jar oak-run-\*.jar檢查 — bin=-1 /path/to/crx-quickstart/repository/segmentstore此功能會在修訂版本中向後搜索，直到找到一致的版本：尋找如下的訊息：主要資訊o.a.j.o.p.s.f.t.ConsistencyChecker — 找到最新的正確修訂afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. 編輯將存放庫還原為此修訂版本。/crx-quickstart/repository/segmentstore/journal.log ，並刪除包含最新良好修訂的行之後的所有行。
5. 全部移除。/crx-quickstart/repository/segmentstore/\*.bak檔案。
6. 執行查核點清除，以透過下列命令移除孤立的查核點：java -Xmx6000m -jar oak-run-\*.jar查核點/path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. 最後，壓縮儲存庫：java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*在某些情況下，oak run check無法找到正確的修訂版本，且在執行check命令時，我們會收到「ConsistencyChecker — 未找到正確的修訂版本」。*
<b>在一致性檢查中遇到「ConsistencyChecker — 未找到正確修訂」時，如何修復損壞</b>


<b>B.手動刪除損壞的節點。</b>

在AEM中，若未設定FileDatastore且二進位檔中發生損毀，您可以執行下列操作。

\*注意n:\*以下過程適用於高級用戶。  刪除損壞的節點時，您需要確保它們不是系統節點（如/home、/jcr:system等）。  或者，如果它們是系統節點，則需要確保可以恢復它們。  如果您不確定，請洽詢AEM客戶服務團隊，以取得此處說明的步驟協助。



1. 停止AEM。
2. 使用Oak執行主控台並載入childCount groovy指令碼，以識別區段存放區中損毀的節點：


載入oak-run主控台殼層：

java -jar oak-run-\*.jar控制台crx-quickstart/repository/segmentstore

在shell中運行以下兩個命令以載入指令碼並運行它：

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

這會導致以下輸出指示損壞節點的路徑：

21:21:42.029主要錯誤o.a.j.o.p.segment.SegmentTracker — 找不到區段：63ae05a4-b506-445c-baa2-cfa1b13b6e2f。 建立日期差值為3毫秒。

警告無法讀取節點/content/dam/test.txt/jcr:content/renditions/original/jcr:content

在某些情況下，問題連結到二進位屬性，而childCount groovy指令碼找不到任何損壞的節點。  在這些情況下，您可以使用以下命令來代替遍歷過程中遇到的每個二進位元組的前1024個位元組（請注意，此命令的速度會較慢，並且僅當上述命令未返回預期結果時才應使用）:

countNodes(session.workingNode,true)

3. 使用rmNodes.groovy刪除最後一個命令輸出中列出的所有已標識的損壞節點

使用下列命令載入oak-run主控台殼層：

java -jar oak-run-\*.jar控制台crx-quickstart/repository/segmentstore

載入groovy指令碼：

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

運行rmNode命令以刪除損壞的節點，用需要刪除的損壞節點的路徑替換/path/to/corrupt/node。

rmNode(session, &quot;/path/to/corrupt/node&quot;)

其中損壞的節點路徑是在步驟2中獲得的路徑，例如：&quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot;注意：使用oak-run.jar 1.6.13版和更新時，如果您遇到錯誤，請設定 — 讀寫JVM參數，例如：

/ rmNode(session,&quot;/path/to/corrupt/node&quot;)正在刪除節點/path/to/corrupt/node錯誤java.lang.UnsupportedOperationException:   無法寫入org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute(SegmentWriterBuilder.java:171)，位於org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode(SegmentWriter.java:318)，位於org.apache.jak.jarbbit.segmentNodeBuilder.getNodeState(SegmentNodeNodeNodeNode.builder.111.og.javabe.javabe.javabit.se.se.segment)在org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge(SegmentNodeStore.java:333)，在org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call（未知來源），在groovysh_evaluate.rmNode(groovysh_evaluate:11)

4. 對於在步驟2中找到的所有節點，重複步驟3。

對於損壞的路徑，上述rmNode命令應返回true，這表示它已將其刪除。 通過在這些路徑上重新運行rmNode命令，確保刪除這些發現的三個損壞路徑。 下次執行時應會傳回false。

如果您仍然看到存放庫中有相同的路徑，請使用修補版本的oak-run jar，即oak-run-1.2.18-NPR-17596

Oak run Jar的修補版本是什麼？

此版本的jar會在壓縮時略過無法讀取的二進位檔，取代為0位元組二進位檔，並記錄例外狀況和syser的路徑。 如此一來，已壓縮的存放庫應會傳遞oak-run檢查、節點計數指令碼，而您也應能使用未修補的oak-run再次將其壓縮。

5. 使用下方列出查核點，以執行查核點清除。 如果有多個查核點，請加以清除：

nohup java -Xmx4096m -jar oak-run-1.2.18.jar查核點/app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &amp;

6. 執行離線壓縮。  如果您不知道如何執行離線壓縮，請參閱 [此處](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. 啟動伺服器等待索引完成。
